[{"path":"index.html","id":"bienvenidos","chapter":"Capítulo 1 ¡Bienvenidos!","heading":"Capítulo 1 ¡Bienvenidos!","text":"","code":""},{"path":"index.html","id":"acerca-del-curso","chapter":"Capítulo 1 ¡Bienvenidos!","heading":"1.1 Acerca del curso","text":"","code":""},{"path":"index.html","id":"exploración-competencial","chapter":"Capítulo 1 ¡Bienvenidos!","heading":"1.2 Exploración competencial","text":"","code":""},{"path":"sesión-01.html","id":"sesión-01","chapter":"Capítulo 2 Sesión 01","heading":"Capítulo 2 Sesión 01","text":"","code":""},{"path":"sesión-01.html","id":"qué-es-ciencia-de-datos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.1 ¿Qué es Ciencia de Datos?","text":"La Ciencia de Datos es una fusión entre múltiples disciplinas, incluyendo matematicas, estadistica, informatica, y tecnologia de la información.La Ciencia de Datos permite extraer información relevante de los datos.","code":""},{"path":"sesión-01.html","id":"por-qué-usar-r-para-ciencia-de-datos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.2 ¿Por qué usar R para Ciencia de Datos?","text":"R cuenta con las herramientas necesarias (entorno, librerías, y funciones) para desarrollar proyectos de Ciencia de Datos.","code":""},{"path":"sesión-01.html","id":"reconocimiento-rstudio","chapter":"Capítulo 2 Sesión 01","heading":"2.0.3 Reconocimiento Rstudio","text":"","code":""},{"path":"sesión-01.html","id":"mover-paneles","chapter":"Capítulo 2 Sesión 01","heading":"2.0.4 Mover paneles","text":"","code":""},{"path":"sesión-01.html","id":"personalización-de-rstudio","chapter":"Capítulo 2 Sesión 01","heading":"2.0.5 Personalización de Rstudio","text":"Modificaciones sobre la interfaz de Rstudio:Aumentar el zoom o utilizar el atajo: Ctrl y +Aumentar el zoom o utilizar el atajo: Ctrl y +Cambiar tipo de letra puede hacer un tanto más agradable la codificación. La letra FiraCambiar tipo de letra puede hacer un tanto más agradable la codificación. La letra FiraCode es bastante recomendable, pero se requiere instalar.Code es bastante recomendable, pero se requiere instalar.El tema también puede ayudar en que la codificación sea más agradable. El paquete rsthemes, contiene muchos temas extras.El tema también puede ayudar en que la codificación sea más agradable. El paquete rsthemes, contiene muchos temas extras.","code":""},{"path":"sesión-01.html","id":"por-qué-utilizar-proyectos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.6 ¿Por qué utilizar proyectos?","text":"Es más fácil poder compartir los proyectos y estos se encuentran listos para que otras personas puedan colaborar contigo.Es más fácil poder compartir los proyectos y estos se encuentran listos para que otras personas puedan colaborar contigo.Cada proyecto se encuentra aislado. Los códigos en un proyecto afectarán ningún otro. Puedes tener muchos proyectos abiertos y los códigos del proyecto 1 afectarán al proyecto 2.Cada proyecto se encuentra aislado. Los códigos en un proyecto afectarán ningún otro. Puedes tener muchos proyectos abiertos y los códigos del proyecto 1 afectarán al proyecto 2.Muy útil para facilitar la importación de data.Muy útil para facilitar la importación de data.Mejora tanto la reproducibilidad como la colaboración.Mejora tanto la reproducibilidad como la colaboración.","code":""},{"path":"sesión-01.html","id":"creación-de-proyectos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.7 Creación de proyectos","text":"PASOS:Seleccionamos “Project (None)” o “File” y luego, new project.“New Directory” se utiliza para indicar dónde voy almacenar mis archivos y para que R cree una nueva carpeta para mi proyecto, mientras que “Existing Directory” se utiliza si ya tengo una carpeta en la cual voy almacenar mis archivos. Seleccionamos “New Directory”.Aparecerán más opciones y seleccionamos nuevamente “New Project”En caso de haber seleccionado “Existing Directory” aparecerá esto y buscamos el nombre de la carpeta que utilizaremos.En “Directory name” ponemos el nombre de la carpeta que contendrá el archivo del proyecto, mientras que en “Create project subdirectory ” seleccionamos dónde está la carpeta en la que trabajaremos.Resumen","code":""},{"path":"sesión-01.html","id":"vectores-atómicos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.8 Vectores atómicos","text":"Los vectores contienen información homogénea o siempre de un solo tipo de datos.Los vectores contienen información homogénea o siempre de un solo tipo de datos.Un vector puede contener 1 solo elemento o n-elementos.Un vector puede contener 1 solo elemento o n-elementos.Existen hasta 6 tipos de datos que puede contener un vector:\nLogical: TRUE, FALSE\nInteger: 1, 5, 7\nDouble: 3.15, 10, 12.86\nCharacter: \"Marcos\", \"Laptop\".\nComplex: 3 + 2i\nExisten hasta 6 tipos de datos que puede contener un vector:Logical: TRUE, FALSEInteger: 1, 5, 7Double: 3.15, 10, 12.86Character: \"Marcos\", \"Laptop\".Complex: 3 + 2iEjemplos:Los vectores solo pueden tener un solo tipo de información la vez, así que si dentro de un vector se ingresa un elemento tipo numeric, este inmediatamente será transformado character.Ahora crearemos 2 vectores llamados nombres y edades.partir de esto, podemos construir algo con lo que probablemente estemos más familiarizados.","code":"\nv_numeric <- 5\nv_numeric\n#> [1] 5\nv_numeric <- c(5, 10, 15)\nv_numeric\n#> [1]  5 10 15\ntypeof(v_numeric)\n#> [1] \"double\"\nv_character <- c(\"Laptop\", \"Rstudio\", \"4.2\")\nv_character\n#> [1] \"Laptop\"  \"Rstudio\" \"4.2\"\nv_character <- c(\"Laptop\", \"Rstudio\", 4.2)\nv_character\n#> [1] \"Laptop\"  \"Rstudio\" \"4.2\"\ntypeof(v_character)\n#> [1] \"character\"\nnombres <- c(\"Luis\", \"Mateo\", \"Carlos\", \"Eduardo\")\nedades <- c(28, 30, 40, 35)\ndata.frame(nombres, \n           edades)\n#>   nombres edades\n#> 1    Luis     28\n#> 2   Mateo     30\n#> 3  Carlos     40\n#> 4 Eduardo     35"},{"path":"sesión-02.html","id":"sesión-02","chapter":"Capítulo 3 Sesión 02","heading":"Capítulo 3 Sesión 02","text":"","code":""},{"path":"sesión-02.html","id":"qué-es-una-función","chapter":"Capítulo 3 Sesión 02","heading":"3.0.1 ¿Qué es una función?","text":"Las funciones son módulos de código autónomo que realizan una tarea específica y generalmente, toman algún tipo de estructura de datos (vector, dataframes, etc.), lo procesan y devuelven un resultado.El uso general de una función es el nombre de la función seguida de paréntesisLos inputs se denominan argumentos e incluyen:El objeto físico (cualquier estructura de datos) en el que la función lleva cabo una tarea.El objeto físico (cualquier estructura de datos) en el que la función lleva cabo una tarea.Especificaciones que alteran la forma en que opera la funciónEspecificaciones que alteran la forma en que opera la función","code":"function_name(input)"},{"path":"sesión-02.html","id":"buscando-ayuda-sobre-las-funciones","chapter":"Capítulo 3 Sesión 02","heading":"3.0.2 Buscando ayuda sobre las funciones","text":"La mejor forma de averiguar esta información es utilizar ? seguido del nombre de la función. Al hacer esto, se abrirá el manual de ayuda en el panel inferior derecho de RStudio que proporcionará una descripción de la función, uso, argumentos, detalles y ejemplos:?sdhelp(sd)Alternativamente, si está familiarizado con la función pero solo necesita recordar los nombres de los argumentos, puede usar:","code":"\nargs(sd)## function (x, na.rm = FALSE) \n## NULL"},{"path":"sesión-02.html","id":"ejemplo-de-una-función","chapter":"Capítulo 3 Sesión 02","heading":"3.0.3 Ejemplo de una función","text":"Se tiene el número 3.15181930, pero solo necesitamos dos decimales. Para ello, utilizaremos la función round() que redondea los números de acuerdo la cantidad de decimales que asignemos. En este caso, solo necesitaremos 2.Como se puede observar, se ha utilizado el argumento digits para regular la cantidad de decimales.Nota: Si proporcionamos los argumentos en el mismo orden en el que han sido definidos, es necesario nombrarlos","code":"\nround(3.15181930, digits = 2)\n#> [1] 3.15\nround(3.15181930, 2)\n#> [1] 3.15"},{"path":"sesión-02.html","id":"data.frame","chapter":"Capítulo 3 Sesión 02","heading":"3.0.4 ¿Data.frame?","text":"Estructura de datos 2DEstructura de datos 2DAdmite datos con diferente tipo de variable (lo opuesto matrices)Admite datos con diferente tipo de variable (lo opuesto matrices)Similar Microsoft ExcelSimilar Microsoft ExcelSe crean con la función:","code":"data.frame(\n  Var1 = elementos1,\n  Var2 = elementos2\n)\nvar1 <- c(\"Peru\", \"Argentina\", \"Bolivia\")\nvar2 <- rep(\"aceptado\",3)\nvar3 <- seq(1000,1200,100)\ndf <- data.frame(var1, var2, var3)\ndf\n#>        var1     var2 var3\n#> 1      Peru aceptado 1000\n#> 2 Argentina aceptado 1100\n#> 3   Bolivia aceptado 1200\ndf <- data.frame(\n  var1 = c(\"Peru\", \"Argentina\", \"Bolivia\"),\n  var2 = rep(\"aceptado\",3),\n  var3 = seq(1000,1200,100)\n)\ndf\n#>        var1     var2 var3\n#> 1      Peru aceptado 1000\n#> 2 Argentina aceptado 1100\n#> 3   Bolivia aceptado 1200"},{"path":"sesión-02.html","id":"tibble","chapter":"Capítulo 3 Sesión 02","heading":"3.0.5 ¿Tibble?","text":"Son la versión mejorada del data.frameDisponible en el paquete tibble y por lo tanto en el tidyverse.Se crean con la función:","code":"# Instalación\ninstall.packages(\"tibble\")\n# Llavado o activación de paquete\nlibrary(tibble)\ntibble(\n  Var1 = elementos1,\n  Var2 = elementos2\n)\nlibrary(tibble)\ntibble(\n  var1 = c(\"Peru\", \"Argentina\", \"Bolivia\"),\n  var2 = rep(\"aceptado\",3),\n  var3 = seq(1000,1200,100)\n)\n#> # A tibble: 3 × 3\n#>   var1      var2      var3\n#>   <chr>     <chr>    <dbl>\n#> 1 Peru      aceptado  1000\n#> 2 Argentina aceptado  1100\n#> 3 Bolivia   aceptado  1200"},{"path":"sesión-02.html","id":"data.frame-v.s.-tibble","chapter":"Capítulo 3 Sesión 02","heading":"3.0.6 data.frame() v.s. tibble()","text":"Ambas funciones tienen sus versiones .* o as_* que permite transformar algo en lo que se desea. En este caso se estaría usando .data.frame para convertir algo data.frame y as_tibble para ese mismo objetivo.","code":"\nclass(iris)\n#> [1] \"data.frame\"\n# data.frame\nhead(iris) # Muestra las 6 primeras filas del data.frame\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n# tibble\nas_tibble(iris)\n#> # A tibble: 150 × 5\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1          5.1         3.5          1.4         0.2 setosa \n#>  2          4.9         3            1.4         0.2 setosa \n#>  3          4.7         3.2          1.3         0.2 setosa \n#>  4          4.6         3.1          1.5         0.2 setosa \n#>  5          5           3.6          1.4         0.2 setosa \n#>  6          5.4         3.9          1.7         0.4 setosa \n#>  7          4.6         3.4          1.4         0.3 setosa \n#>  8          5           3.4          1.5         0.2 setosa \n#>  9          4.4         2.9          1.4         0.2 setosa \n#> 10          4.9         3.1          1.5         0.1 setosa \n#> # … with 140 more rows"},{"path":"sesión-02.html","id":"qué-es-un-paquete","chapter":"Capítulo 3 Sesión 02","heading":"3.0.7 ¿Qué es un paquete?","text":"Los paquetes son colecciones de funciones, datos y código compilado de R en un formato bien definido, creados para agregar una funcionalidad específica.Hay un conjunto de paquetes estándar (o base) que se consideran parte del código fuente de R y están disponibles automáticamente como parte de su instalación de R.","code":""},{"path":"sesión-02.html","id":"instalación-de-paquetes-desde-cran","chapter":"Capítulo 3 Sesión 02","heading":"3.0.8 Instalación de paquetes desde CRAN","text":"La forma de instalar un paquete dependerá de dónde se encuentre. Entonces, para los paquetes disponibles públicamente, esto significa qué repositorio pertenece. La forma más común es usar el repositorio CRAN, luego solo necesita el nombre del paquete y usa el siguiente comando:Después de ejecutar esto, recibirá algunos mensajes en la pantalla. Dependerán del sistema operativo que esté utilizando, las dependencias y si el paquete se instaló correctamente.","code":"\ninstall.packages(\"paquete\")"},{"path":"sesión-02.html","id":"instalación-de-paquetes-vía-remotes","chapter":"Capítulo 3 Sesión 02","heading":"3.0.9 Instalación de paquetes vía remotes","text":"Cada repositorio tiene su propia forma de instalar un paquete partir de ellos, por lo que en el caso de que utilice regularmente paquetes de diferentes fuentes, este comportamiento puede ser un poco frustrante. Una forma más eficiente es probablemente usar el paquete remotes para simplificar este proceso.Después de haber instalado remotes podemos utilizar algunas de sus funciones para la instalación de paquetes:remotes::install_bioc() desde Bioconductorremotes::install_bioc() desde Bioconductorremotes::install_github() desde GitHubremotes::install_github() desde GitHubremotes::install_version() para instalar una versión específica de CRAN.remotes::install_version() para instalar una versión específica de CRAN.","code":"\ninstall.packages(\"remotes\")"},{"path":"sesión-02.html","id":"importación-de-datos","chapter":"Capítulo 3 Sesión 02","heading":"3.0.10 Importación de datos","text":"","code":""}]
