[{"path":"index.html","id":"bienvenidos","chapter":"Capítulo 1 ¡Bienvenidos!","heading":"Capítulo 1 ¡Bienvenidos!","text":"Esta página es el contenido del curso en formato bookdown. Puedes visitar el repositorio del curso para poder ver el código fuente del resto de materiales del curso.","code":""},{"path":"index.html","id":"acerca-del-curso","chapter":"Capítulo 1 ¡Bienvenidos!","heading":"1.1 Acerca del curso","text":"Este curso busca introducir al estudiante en el uso de R y el uso del metapaquete tidyverse para el manejo inicial de datos durante un proceso de investigación.Al finalizar el curso de manera satisfactoria, el participante podrá:Importar conjuntos de datos de los principales formatos que se trabajan en proyectos de investigación.Dar formato inicial al conjunto de datos mediante reconocimiento de variables y modificaciones en las mismas.Ejecutar modificaciones en variables pre-existentes y nuevas variables que se introduzcan.Trabajar con múltiples bases de datos y unificarlas de acuerdo al objetivo de investigación planteado.","code":""},{"path":"sesión-01.html","id":"sesión-01","chapter":"Capítulo 2 Sesión 01","heading":"Capítulo 2 Sesión 01","text":"","code":""},{"path":"sesión-01.html","id":"qué-es-ciencia-de-datos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.1 ¿Qué es Ciencia de Datos?","text":"La Ciencia de Datos es una fusión entre múltiples disciplinas, incluyendo matematicas, estadistica, informatica, y tecnologia de la información.La Ciencia de Datos permite extraer información relevante de los datos.","code":""},{"path":"sesión-01.html","id":"por-qué-usar-r-para-ciencia-de-datos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.2 ¿Por qué usar R para Ciencia de Datos?","text":"R cuenta con las herramientas necesarias (entorno, librerías, y funciones) para desarrollar proyectos de Ciencia de Datos.","code":""},{"path":"sesión-01.html","id":"reconocimiento-rstudio","chapter":"Capítulo 2 Sesión 01","heading":"2.0.3 Reconocimiento Rstudio","text":"","code":""},{"path":"sesión-01.html","id":"mover-paneles","chapter":"Capítulo 2 Sesión 01","heading":"2.0.4 Mover paneles","text":"","code":""},{"path":"sesión-01.html","id":"personalización-de-rstudio","chapter":"Capítulo 2 Sesión 01","heading":"2.0.5 Personalización de Rstudio","text":"","code":""},{"path":"sesión-01.html","id":"modificaciones-sobre-la-interfaz-de-rstudio","chapter":"Capítulo 2 Sesión 01","heading":"2.0.5.1 Modificaciones sobre la interfaz de Rstudio:","text":"Aumentar el zoom o utilizar el atajo: Ctrl y +Aumentar el zoom o utilizar el atajo: Ctrl y +Cambiar tipo de letra puede hacer un tanto más agradable la codificación. La letra FiraCambiar tipo de letra puede hacer un tanto más agradable la codificación. La letra FiraCode es bastante recomendable, pero se requiere instalar.Code es bastante recomendable, pero se requiere instalar.El tema también puede ayudar en que la codificación sea más agradable. El paquete rsthemes, contiene muchos temas extras.El tema también puede ayudar en que la codificación sea más agradable. El paquete rsthemes, contiene muchos temas extras.","code":""},{"path":"sesión-01.html","id":"por-qué-utilizar-proyectos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.6 ¿Por qué utilizar proyectos?","text":"Es más fácil poder compartir los proyectos y estos se encuentran listos para que otras personas puedan colaborar contigo.Es más fácil poder compartir los proyectos y estos se encuentran listos para que otras personas puedan colaborar contigo.Cada proyecto se encuentra aislado. Los códigos en un proyecto afectarán ningún otro. Puedes tener muchos proyectos abiertos y los códigos del proyecto 1 afectarán al proyecto 2.Cada proyecto se encuentra aislado. Los códigos en un proyecto afectarán ningún otro. Puedes tener muchos proyectos abiertos y los códigos del proyecto 1 afectarán al proyecto 2.Muy útil para facilitar la importación de data.Muy útil para facilitar la importación de data.Mejora tanto la reproducibilidad como la colaboración.Mejora tanto la reproducibilidad como la colaboración.","code":""},{"path":"sesión-01.html","id":"creación-de-proyectos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.7 Creación de proyectos","text":"PASOS:Seleccionamos “Project (None)” o “File” y luego, new project.“New Directory” se utiliza para indicar dónde voy almacenar mis archivos y para que R cree una nueva carpeta para mi proyecto, mientras que “Existing Directory” se utiliza si ya tengo una carpeta en la cual voy almacenar mis archivos. Seleccionamos “New Directory”.Aparecerán más opciones y seleccionamos nuevamente “New Project”En caso de haber seleccionado “Existing Directory” aparecerá esto y buscamos el nombre de la carpeta que utilizaremos.En “Directory name” ponemos el nombre de la carpeta que contendrá el archivo del proyecto, mientras que en “Create project subdirectory ” seleccionamos dónde está la carpeta en la que trabajaremos.Resumen","code":""},{"path":"sesión-01.html","id":"vectores-atómicos","chapter":"Capítulo 2 Sesión 01","heading":"2.0.8 Vectores atómicos","text":"Los vectores contienen información homogénea o siempre de un solo tipo de datos.Los vectores contienen información homogénea o siempre de un solo tipo de datos.Un vector puede contener 1 solo elemento o n-elementos.Un vector puede contener 1 solo elemento o n-elementos.Existen hasta 6 tipos de datos que puede contener un vector:\nLogical: TRUE, FALSE\nInteger: 1, 5, 7\nDouble: 3.15, 10, 12.86\nCharacter: \"Marcos\", \"Laptop\".\nComplex: 3 + 2i\nExisten hasta 6 tipos de datos que puede contener un vector:Logical: TRUE, FALSEInteger: 1, 5, 7Double: 3.15, 10, 12.86Character: \"Marcos\", \"Laptop\".Complex: 3 + 2iEjemplos:Los vectores solo pueden tener un solo tipo de información la vez, así que si dentro de un vector se ingresa un elemento tipo numeric, este inmediatamente será transformado character.Ahora crearemos 2 vectores llamados nombres y edades.partir de esto, podemos construir algo con lo que probablemente estemos más familiarizados.","code":"\nv_numeric <- 5\nv_numeric\n#> [1] 5\nv_numeric <- c(5, 10, 15)\nv_numeric\n#> [1]  5 10 15\ntypeof(v_numeric)\n#> [1] \"double\"\nv_character <- c(\"Laptop\", \"Rstudio\", \"4.2\")\nv_character\n#> [1] \"Laptop\"  \"Rstudio\" \"4.2\"\nv_character <- c(\"Laptop\", \"Rstudio\", 4.2)\nv_character\n#> [1] \"Laptop\"  \"Rstudio\" \"4.2\"\ntypeof(v_character)\n#> [1] \"character\"\nnombres <- c(\"Luis\", \"Mateo\", \"Carlos\", \"Eduardo\")\nedades <- c(28, 30, 40, 35)\ndata.frame(nombres, \n           edades)\n#>   nombres edades\n#> 1    Luis     28\n#> 2   Mateo     30\n#> 3  Carlos     40\n#> 4 Eduardo     35"},{"path":"sesión-02.html","id":"sesión-02","chapter":"Capítulo 3 Sesión 02","heading":"Capítulo 3 Sesión 02","text":"","code":""},{"path":"sesión-02.html","id":"qué-es-una-función","chapter":"Capítulo 3 Sesión 02","heading":"3.0.1 ¿Qué es una función?","text":"Las funciones son módulos de código autónomo que realizan una tarea específica y generalmente, toman algún tipo de estructura de datos (vector, dataframes, etc.), lo procesan y devuelven un resultado.El uso general de una función es el nombre de la función seguida de paréntesisLos inputs se denominan argumentos e incluyen:El objeto físico (cualquier estructura de datos) en el que la función lleva cabo una tarea.El objeto físico (cualquier estructura de datos) en el que la función lleva cabo una tarea.Especificaciones que alteran la forma en que opera la funciónEspecificaciones que alteran la forma en que opera la función","code":"function_name(input)"},{"path":"sesión-02.html","id":"buscando-ayuda-sobre-las-funciones","chapter":"Capítulo 3 Sesión 02","heading":"3.0.2 Buscando ayuda sobre las funciones","text":"La mejor forma de averiguar esta información es utilizar ? seguido del nombre de la función. Al hacer esto, se abrirá el manual de ayuda en el panel inferior derecho de RStudio que proporcionará una descripción de la función, uso, argumentos, detalles y ejemplos:?sdhelp(sd)Alternativamente, si está familiarizado con la función pero solo necesita recordar los nombres de los argumentos, puede usar:","code":"\nargs(sd)## function (x, na.rm = FALSE) \n## NULL"},{"path":"sesión-02.html","id":"ejemplo-de-una-función","chapter":"Capítulo 3 Sesión 02","heading":"3.0.3 Ejemplo de una función","text":"Se tiene el número 3.15181930, pero solo necesitamos dos decimales. Para ello, utilizaremos la función round() que redondea los números de acuerdo la cantidad de decimales que asignemos. En este caso, solo necesitaremos 2.Como se puede observar, se ha utilizado el argumento digits para regular la cantidad de decimales.Nota: Si proporcionamos los argumentos en el mismo orden en el que han sido definidos, es necesario nombrarlos","code":"\nround(3.15181930, digits = 2)\n#> [1] 3.15\nround(3.15181930, 2)\n#> [1] 3.15"},{"path":"sesión-02.html","id":"data.frame","chapter":"Capítulo 3 Sesión 02","heading":"3.0.4 ¿Data.frame?","text":"Estructura de datos 2DEstructura de datos 2DAdmite datos con diferente tipo de variable (lo opuesto matrices)Admite datos con diferente tipo de variable (lo opuesto matrices)Similar Microsoft ExcelSimilar Microsoft ExcelSe crean con la función:","code":"data.frame(\n  Var1 = elementos1,\n  Var2 = elementos2\n)\nvar1 <- c(\"Peru\", \"Argentina\", \"Bolivia\")\nvar2 <- rep(\"aceptado\",3)\nvar3 <- seq(1000,1200,100)\ndf <- data.frame(var1, var2, var3)\ndf\n#>        var1     var2 var3\n#> 1      Peru aceptado 1000\n#> 2 Argentina aceptado 1100\n#> 3   Bolivia aceptado 1200\ndf <- data.frame(\n  var1 = c(\"Peru\", \"Argentina\", \"Bolivia\"),\n  var2 = rep(\"aceptado\",3),\n  var3 = seq(1000,1200,100)\n)\ndf\n#>        var1     var2 var3\n#> 1      Peru aceptado 1000\n#> 2 Argentina aceptado 1100\n#> 3   Bolivia aceptado 1200"},{"path":"sesión-02.html","id":"tibble","chapter":"Capítulo 3 Sesión 02","heading":"3.0.5 ¿Tibble?","text":"Son la versión mejorada del data.frameDisponible en el paquete tibble y por lo tanto en el tidyverse.Se crean con la función:","code":"# Instalación\ninstall.packages(\"tibble\")\n# Llavado o activación de paquete\nlibrary(tibble)\ntibble(\n  Var1 = elementos1,\n  Var2 = elementos2\n)\nlibrary(tibble)\ntibble(\n  var1 = c(\"Peru\", \"Argentina\", \"Bolivia\"),\n  var2 = rep(\"aceptado\",3),\n  var3 = seq(1000,1200,100)\n)\n#> # A tibble: 3 × 3\n#>   var1      var2      var3\n#>   <chr>     <chr>    <dbl>\n#> 1 Peru      aceptado  1000\n#> 2 Argentina aceptado  1100\n#> 3 Bolivia   aceptado  1200"},{"path":"sesión-02.html","id":"data.frame-v.s.-tibble","chapter":"Capítulo 3 Sesión 02","heading":"3.0.6 data.frame() v.s. tibble()","text":"Ambas funciones tienen sus versiones .* o as_* que permite transformar algo en lo que se desea. En este caso se estaría usando .data.frame para convertir algo data.frame y as_tibble para ese mismo objetivo.","code":"\nclass(iris)\n#> [1] \"data.frame\"\n# data.frame\nhead(iris) # Muestra las 6 primeras filas del data.frame\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#> 1          5.1         3.5          1.4         0.2  setosa\n#> 2          4.9         3.0          1.4         0.2  setosa\n#> 3          4.7         3.2          1.3         0.2  setosa\n#> 4          4.6         3.1          1.5         0.2  setosa\n#> 5          5.0         3.6          1.4         0.2  setosa\n#> 6          5.4         3.9          1.7         0.4  setosa\n# tibble\nas_tibble(iris)\n#> # A tibble: 150 × 5\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1          5.1         3.5          1.4         0.2 setosa \n#>  2          4.9         3            1.4         0.2 setosa \n#>  3          4.7         3.2          1.3         0.2 setosa \n#>  4          4.6         3.1          1.5         0.2 setosa \n#>  5          5           3.6          1.4         0.2 setosa \n#>  6          5.4         3.9          1.7         0.4 setosa \n#>  7          4.6         3.4          1.4         0.3 setosa \n#>  8          5           3.4          1.5         0.2 setosa \n#>  9          4.4         2.9          1.4         0.2 setosa \n#> 10          4.9         3.1          1.5         0.1 setosa \n#> # … with 140 more rows"},{"path":"sesión-02.html","id":"qué-es-un-paquete","chapter":"Capítulo 3 Sesión 02","heading":"3.0.7 ¿Qué es un paquete?","text":"Los paquetes son colecciones de funciones, datos y código compilado de R en un formato bien definido, creados para agregar una funcionalidad específica.Hay un conjunto de paquetes estándar (o base) que se consideran parte del código fuente de R y están disponibles automáticamente como parte de su instalación de R.","code":""},{"path":"sesión-02.html","id":"instalación-de-paquetes-desde-cran","chapter":"Capítulo 3 Sesión 02","heading":"3.0.8 Instalación de paquetes desde CRAN","text":"La forma de instalar un paquete dependerá de dónde se encuentre. Entonces, para los paquetes disponibles públicamente, esto significa qué repositorio pertenece. La forma más común es usar el repositorio CRAN, luego solo necesita el nombre del paquete y usa el siguiente comando:Después de ejecutar esto, recibirá algunos mensajes en la pantalla. Dependerán del sistema operativo que esté utilizando, las dependencias y si el paquete se instaló correctamente.","code":"\ninstall.packages(\"paquete\")"},{"path":"sesión-02.html","id":"instalación-de-paquetes-vía-remotes","chapter":"Capítulo 3 Sesión 02","heading":"3.0.9 Instalación de paquetes vía remotes","text":"Cada repositorio tiene su propia forma de instalar un paquete partir de ellos, por lo que en el caso de que utilice regularmente paquetes de diferentes fuentes, este comportamiento puede ser un poco frustrante. Una forma más eficiente es probablemente usar el paquete remotes para simplificar este proceso.Después de haber instalado remotes podemos utilizar algunas de sus funciones para la instalación de paquetes:remotes::install_bioc() desde Bioconductorremotes::install_bioc() desde Bioconductorremotes::install_github() desde GitHubremotes::install_github() desde GitHubremotes::install_version() para instalar una versión específica de CRAN.remotes::install_version() para instalar una versión específica de CRAN.","code":"\ninstall.packages(\"remotes\")"},{"path":"sesión-02.html","id":"bases-de-datos-a-utilizar","chapter":"Capítulo 3 Sesión 02","heading":"3.0.10 Bases de datos a utilizar","text":"Usaremos una base de datos proporcionado por Gan et al. (2018) en su estudio:Dicho estudio es un ensayo clínico aleatorizado (ECA) de 400 participantes en el que se compara 2 tipos de tratamientos para erradicar la infección por Helicobácter Pylori.Grupo de tratamiento: Esomeprazol, amoxicilina, bismuto coloidal con pectina y levofloxacina 500mg una vez al día.Grupo de tratamiento: Esomeprazol, amoxicilina, bismuto coloidal con pectina y levofloxacina 500mg una vez al día.Grupo B de tratamiento: Levofloxacina 200mg dos veces al día, durante un periodo de 14 días.Grupo B de tratamiento: Levofloxacina 200mg dos veces al día, durante un periodo de 14 días.","code":""},{"path":"sesión-02.html","id":"importación-de-datos-i","chapter":"Capítulo 3 Sesión 02","heading":"3.0.11 Importación de datos I","text":"Vamos importar el archivo excel que tiene una extensión .xlsx y se encuentra dentro de la carpeta data.Recuerda: Al importar el archivo debemos asignarlo un objeto, para poder guardar la información. En este caso llamaremos este objeto como trial_data.","code":"#> ── Attaching packages ────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✔ ggplot2 3.3.6     ✔ dplyr   1.0.9\n#> ✔ tidyr   1.2.0     ✔ stringr 1.4.0\n#> ✔ readr   2.1.2     ✔ forcats 0.5.1\n#> ✔ purrr   0.3.4\n#> ── Conflicts ───────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\ntrial_data <- readxl::read_excel(\"_data/researchdata.xlsx\")\ntrial_data\n#> # A tibble: 400 × 10\n#>    `Patient number` `Baseline 13C-UBT` `Randomized group`\n#>               <dbl> <chr>              <chr>             \n#>  1                1 Positive           group B           \n#>  2                2 Positive           group A           \n#>  3                3 Positive           group B           \n#>  4                4 Positive           group A           \n#>  5                5 Positive           group A           \n#>  6                6 Positive           group A           \n#>  7                7 Positive           group B           \n#>  8                8 Positive           group A           \n#>  9                9 Positive           group A           \n#> 10               10 Positive           group A           \n#> # … with 390 more rows, and 7 more variables:\n#> #   `Follow-up13C-UBT (4 weeks after therapy)` <chr>,\n#> #   `adverse drug reactions` <chr>,\n#> #   `adverse drug reactions  content` <chr>,\n#> #   `Adverse drug reaction classified` <chr>,\n#> #   `Complete the study` <chr>, `Uncompleted Reason` <chr>,\n#> #   `per protocol analysis` <chr>"},{"path":"sesión-02.html","id":"importación-de-datos-ii","chapter":"Capítulo 3 Sesión 02","heading":"3.0.12 Importación de datos II","text":"En algunos casos estaremos frente base de datos que contengan cierta información en sus primeras filas que sean relevantes como datos considerar para el análisis. La mayor cantidad de veces tienen un propósito meramente informativo. Ejemplo:","code":""},{"path":"sesión-02.html","id":"situación","chapter":"Capítulo 3 Sesión 02","heading":"3.0.12.1 Situación","text":"En estas situaciones tenemos 2 alternativas:) Editar el archivo en cuestión y eliminar las filas que sean relevantes.b) Durante la importación indicar que se omitan las primeras filas o filtrarlas una vez se haya importado.Siempre será una mejor opción manejar los cambios desde el código, ya que se esa manera mantenemos los archivos originales y además podemos tener un registro de los cambios realizados.Para hacer esto usaremos el argumento skip dentro de la función readxl::read_excel(), que indicará la cantidad de filas que deseamos omitir en la importación.","code":""},{"path":"sesión-02.html","id":"problema","chapter":"Capítulo 3 Sesión 02","heading":"3.0.12.2 Problema","text":"Si intentamos importar la data sin especificar ningún argumento, veremos como se registran informaciones que requerimos, y solo se encuentran en los datos manera de información.","code":"\ntrial_data2 <- readxl::read_excel(\"_data/researchdata2.xlsx\")\n#> New names:\n#> • `` -> `...1`\n#> • `` -> `...3`\n#> • `` -> `...4`\n#> • `` -> `...5`\n#> • `` -> `...6`\n#> • `` -> `...7`\n#> • `` -> `...8`\n#> • `` -> `...9`\n#> • `` -> `...10`\ntrial_data2\n#> # A tibble: 403 × 10\n#>    ...1       `Data de ejemp…` ...3  ...4  ...5  ...6  ...7 \n#>    <chr>      <chr>            <chr> <chr> <chr> <chr> <chr>\n#>  1 <NA>       <NA>             <NA>  <NA>  <NA>  <NA>  <NA> \n#>  2 <NA>       <NA>             <NA>  <NA>  <NA>  <NA>  <NA> \n#>  3 Patient n… Baseline 13C-UBT Rand… Foll… adve… adve… Adve…\n#>  4 1          Positive         grou… Nega… No    NA    NA   \n#>  5 2          Positive         grou… Nega… Yes   Fati… Mild \n#>  6 3          Positive         grou… Nega… No    NA    NA   \n#>  7 4          Positive         grou… Posi… Yes   Abdo… Mild \n#>  8 5          Positive         grou… Nega… Yes   Drow… Mild \n#>  9 6          Positive         grou… Nega… No    NA    NA   \n#> 10 7          Positive         grou… Nega… No    NA    NA   \n#> # … with 393 more rows, and 3 more variables: ...8 <chr>,\n#> #   ...9 <chr>, ...10 <chr>"},{"path":"sesión-02.html","id":"solución","chapter":"Capítulo 3 Sesión 02","heading":"3.0.12.3 Solución","text":"Ya que en este caso la base de datos llamada researchdata2.xlsx empieza mostrar datos relevantes partir de la fila 4, requeriremos omitir o saltar (skip) 3 filas, se la siguiente manera:","code":"\ntrial_data2 <- readxl::read_excel(\n  \"_data/researchdata2.xlsx\",\n  skip = 3\n  )\n\ntrial_data2\n#> # A tibble: 400 × 10\n#>    `Patient number` `Baseline 13C-UBT` `Randomized group`\n#>               <dbl> <chr>              <chr>             \n#>  1                1 Positive           group B           \n#>  2                2 Positive           group A           \n#>  3                3 Positive           group B           \n#>  4                4 Positive           group A           \n#>  5                5 Positive           group A           \n#>  6                6 Positive           group A           \n#>  7                7 Positive           group B           \n#>  8                8 Positive           group A           \n#>  9                9 Positive           group A           \n#> 10               10 Positive           group A           \n#> # … with 390 more rows, and 7 more variables:\n#> #   `Follow-up13C-UBT (4 weeks after therapy)` <chr>,\n#> #   `adverse drug reactions` <chr>,\n#> #   `adverse drug reactions  content` <chr>,\n#> #   `Adverse drug reaction classified` <chr>,\n#> #   `Complete the study` <chr>, `Uncompleted Reason` <chr>,\n#> #   `per protocol analysis` <chr>"},{"path":"sesión-03.html","id":"sesión-03","chapter":"Capítulo 4 Sesión 03","heading":"Capítulo 4 Sesión 03","text":"","code":""},{"path":"sesión-03.html","id":"función-glimpse","chapter":"Capítulo 4 Sesión 03","heading":"4.0.1 Función Glimpse","text":"Mediante la función:","code":"\nglimpse()"},{"path":"sesión-03.html","id":"para-que-sirve","chapter":"Capítulo 4 Sesión 03","heading":"4.0.1.1 ¿Para que sirve?","text":"Versión transpuesta de printVersión transpuesta de printAyuda visualizar la mayor cantidad de datos de muchas columnas.Ayuda visualizar la mayor cantidad de datos de muchas columnas.Muestra el nombre de la variable junto con una designación de tipo de variable.Muestra el nombre de la variable junto con una designación de tipo de variable.Observación:Recordar importar el paquete tidyverse:Para el ejemplo se recomienda installar el siguiente paquete:","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n#> ✔ tibble  3.1.7     ✔ dplyr   1.0.9\n#> ✔ tidyr   1.2.0     ✔ stringr 1.4.0\n#> ✔ readr   2.1.2     ✔ forcats 0.5.1\n#> ── Conflicts ───────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\nlibrary(dplyr)\ninstall.packages(\"nycflights13\")"},{"path":"sesión-03.html","id":"ejemplo","chapter":"Capítulo 4 Sesión 03","heading":"4.0.1.2 Ejemplo","text":"Así habitualmente observamos la data:Con glimpse(), podrás tener un vistazo rápido de la estructura de los datos:Generalmente la vista de glimpse() es suficientemente ordenada para poder observar la estructura de la data sin problemas. Pero también se puede usar el argumento width para poder especificar ello.","code":"\nnycflights13::flights\n#> # A tibble: 336,776 × 19\n#>     year month   day dep_time sched_dep_time dep_delay\n#>    <int> <int> <int>    <int>          <int>     <dbl>\n#>  1  2013     1     1      517            515         2\n#>  2  2013     1     1      533            529         4\n#>  3  2013     1     1      542            540         2\n#>  4  2013     1     1      544            545        -1\n#>  5  2013     1     1      554            600        -6\n#>  6  2013     1     1      554            558        -4\n#>  7  2013     1     1      555            600        -5\n#>  8  2013     1     1      557            600        -3\n#>  9  2013     1     1      557            600        -3\n#> 10  2013     1     1      558            600        -2\n#> # … with 336,766 more rows, and 13 more variables:\n#> #   arr_time <int>, sched_arr_time <int>, arr_delay <dbl>,\n#> #   carrier <chr>, flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>,\n#> #   distance <dbl>, hour <dbl>, minute <dbl>,\n#> #   time_hour <dttm>\nglimpse(nycflights13::flights)\n#> Rows: 336,776\n#> Columns: 19\n#> $ year           <int> 2013, 2013, 2013, 2013, 2013, 2013,…\n#> $ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n#> $ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n#> $ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, …\n#> $ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, …\n#> $ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2…\n#> $ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913,…\n#> $ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854,…\n#> $ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, …\n#> $ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\",…\n#> $ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 5…\n#> $ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804…\n#> $ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", …\n#> $ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", …\n#> $ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, …\n#> $ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1…\n#> $ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6,…\n#> $ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, …\n#> $ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05…glimpse(nycflights13::flights, width = 90)"},{"path":"sesión-03.html","id":"operador-pipe","chapter":"Capítulo 4 Sesión 03","heading":"4.0.2 Operador Pipe %>%","text":"Útil para concatenar múltiples operaciones en dplyr.En algunas ocasiones cuando se desea aplicar una función de forma anidada puede resultar ilegible o difícil de comprender, aquí un ejemplo.El operador %>% nos permite escribir de una secuencia de operaciones de izquierda derecha :Esta forma de programar hace que los códigos sean más legibles por muchos usarios y más si\nempleamos la siguiente estructura.","code":"\ntabla(formato(coeficiente(data)))\ncoeficiente(data) %>% formato() %>% tabla()\ncoeficiente(data) %>% \n  formato() %>% \n  tabla()"},{"path":"sesión-03.html","id":"función-mutate","chapter":"Capítulo 4 Sesión 03","heading":"4.0.3 Función mutate()","text":"Con mutate() podemos realizar modificaciones en las variables. Por ej. sumar variables, o modificarlas de alguna manera (transformar porcentaje, multiplicarlas por alguna constante, etc.). Estas modificaciones pueden realizarse:Creando una nueva variable partir de otras ya existentes.Creando una nueva variable partir de otras ya existentes.Modificar una variable existente en la misma variable.Modificar una variable existente en la misma variable.","code":""},{"path":"sesión-03.html","id":"ejemplo-1","chapter":"Capítulo 4 Sesión 03","heading":"4.0.3.1 Ejemplo:","text":"Explicación:En una data llamada df se estaría aplicando la función mutate creando una variable llamada New_var partir de otra variable llamada var que está siendo multiplicada por 2.","code":"\nlibrary(tidyverse)\ndf %>% \n  mutate(\n    New_var = var*2\n  )"},{"path":"sesión-03.html","id":"uso-práctico-de-mutate","chapter":"Capítulo 4 Sesión 03","heading":"4.1 Uso práctico de mutate()","text":"","code":""},{"path":"sesión-03.html","id":"reconocimiento-de-base-de-datos","chapter":"Capítulo 4 Sesión 03","heading":"4.1.1 Reconocimiento de Base de datos","text":"Para esta ejemplificación usaremos la base de datos del ECA sobre la erradicación de la infección por Helicobácter Pylori explicado en la sesión 02.","code":"\ntrial_data <- readxl::read_excel(\"_data/researchdata.xlsx\")\ntrial_data\n#> # A tibble: 400 × 10\n#>    `Patient number` `Baseline 13C-UBT` `Randomized group`\n#>               <dbl> <chr>              <chr>             \n#>  1                1 Positive           group B           \n#>  2                2 Positive           group A           \n#>  3                3 Positive           group B           \n#>  4                4 Positive           group A           \n#>  5                5 Positive           group A           \n#>  6                6 Positive           group A           \n#>  7                7 Positive           group B           \n#>  8                8 Positive           group A           \n#>  9                9 Positive           group A           \n#> 10               10 Positive           group A           \n#> # … with 390 more rows, and 7 more variables:\n#> #   `Follow-up13C-UBT (4 weeks after therapy)` <chr>,\n#> #   `adverse drug reactions` <chr>,\n#> #   `adverse drug reactions  content` <chr>,\n#> #   `Adverse drug reaction classified` <chr>,\n#> #   `Complete the study` <chr>, `Uncompleted Reason` <chr>,\n#> #   `per protocol analysis` <chr>\nglimpse(trial_data)\n#> Rows: 400\n#> Columns: 10\n#> $ `Patient number`                           <dbl> 1, 2, 3…\n#> $ `Baseline 13C-UBT`                         <chr> \"Positi…\n#> $ `Randomized group`                         <chr> \"group …\n#> $ `Follow-up13C-UBT (4 weeks after therapy)` <chr> \"Negati…\n#> $ `adverse drug reactions`                   <chr> \"No\", \"…\n#> $ `adverse drug reactions  content`          <chr> \"NA\", \"…\n#> $ `Adverse drug reaction classified`         <chr> \"NA\", \"…\n#> $ `Complete the study`                       <chr> \"Yes\", …\n#> $ `Uncompleted Reason`                       <chr> \"NA\", \"…\n#> $ `per protocol analysis`                    <chr> \"Yes\", …"},{"path":"sesión-03.html","id":"janitor","chapter":"Capítulo 4 Sesión 03","heading":"4.1.2 Janitor","text":"En algunas ocasiones las base de datos contienen nombres de variables muy largas o que incluso pueden contener espacios o símbolos. Una forma sencilla de solucionar ello es mediante el uso de la función clean_names() del paquete janitor.Observación:\n- Para instalar el paquete janitor,empleamos la siguiente función:","code":"\ninstall.packages(\"janitor\")\ntrial_data <- trial_data %>% \n  janitor::clean_names() \ntrial_data\n#> # A tibble: 400 × 10\n#>    patient_number baseline_13c_ubt randomized_group\n#>             <dbl> <chr>            <chr>           \n#>  1              1 Positive         group B         \n#>  2              2 Positive         group A         \n#>  3              3 Positive         group B         \n#>  4              4 Positive         group A         \n#>  5              5 Positive         group A         \n#>  6              6 Positive         group A         \n#>  7              7 Positive         group B         \n#>  8              8 Positive         group A         \n#>  9              9 Positive         group A         \n#> 10             10 Positive         group A         \n#> # … with 390 more rows, and 7 more variables:\n#> #   follow_up13c_ubt_4_weeks_after_therapy <chr>,\n#> #   adverse_drug_reactions <chr>,\n#> #   adverse_drug_reactions_content <chr>,\n#> #   adverse_drug_reaction_classified <chr>,\n#> #   complete_the_study <chr>, uncompleted_reason <chr>,\n#> #   per_protocol_analysis <chr>"},{"path":"sesión-03.html","id":"rename","chapter":"Capítulo 4 Sesión 03","heading":"4.1.3 Rename","text":"pesar de que janitor::clean_names() nos proporciona una gran solución para el formateo de nombres de variables que tienen espacios y/o símbolos, veces podría ser necesario modificar específicamente el nombre de algunas variables. Para ello usaremos la función rename de la siguiente manera:","code":"\ntrial_data <- trial_data %>% \n  rename(\n    follow_4_weeks = follow_up13c_ubt_4_weeks_after_therapy\n  )\ntrial_data\n#> # A tibble: 400 × 10\n#>    patient_number baseline_13c_ubt randomized_group\n#>             <dbl> <chr>            <chr>           \n#>  1              1 Positive         group B         \n#>  2              2 Positive         group A         \n#>  3              3 Positive         group B         \n#>  4              4 Positive         group A         \n#>  5              5 Positive         group A         \n#>  6              6 Positive         group A         \n#>  7              7 Positive         group B         \n#>  8              8 Positive         group A         \n#>  9              9 Positive         group A         \n#> 10             10 Positive         group A         \n#> # … with 390 more rows, and 7 more variables:\n#> #   follow_4_weeks <chr>, adverse_drug_reactions <chr>,\n#> #   adverse_drug_reactions_content <chr>,\n#> #   adverse_drug_reaction_classified <chr>,\n#> #   complete_the_study <chr>, uncompleted_reason <chr>,\n#> #   per_protocol_analysis <chr>"},{"path":"sesión-03.html","id":"mutate-i","chapter":"Capítulo 4 Sesión 03","heading":"4.1.4 Mutate I","text":"Una de las primeras cosas que podemos hacer con mutate durante el primer contacto con la data que trabajemos es:Configurar variables ID como texto (character).Configurar variables ID como texto (character).Configurar variables como factores.Configurar variables como factores.Configurar respuestas NA en caso tengan alguna otra codificación.Configurar respuestas NA en caso tengan alguna otra codificación.Configurar la variable ID","code":"\ntrial_data %>% \n  mutate(\n    patient_number = as.character(patient_number)\n  )\n#> # A tibble: 400 × 10\n#>    patient_number baseline_13c_ubt randomized_group\n#>    <chr>          <chr>            <chr>           \n#>  1 1              Positive         group B         \n#>  2 2              Positive         group A         \n#>  3 3              Positive         group B         \n#>  4 4              Positive         group A         \n#>  5 5              Positive         group A         \n#>  6 6              Positive         group A         \n#>  7 7              Positive         group B         \n#>  8 8              Positive         group A         \n#>  9 9              Positive         group A         \n#> 10 10             Positive         group A         \n#> # … with 390 more rows, and 7 more variables:\n#> #   follow_4_weeks <chr>, adverse_drug_reactions <chr>,\n#> #   adverse_drug_reactions_content <chr>,\n#> #   adverse_drug_reaction_classified <chr>,\n#> #   complete_the_study <chr>, uncompleted_reason <chr>,\n#> #   per_protocol_analysis <chr>"},{"path":"sesión-03.html","id":"mutate-ii","chapter":"Capítulo 4 Sesión 03","heading":"4.1.5 Mutate II","text":"Configurar factoresConfigurar respuestas NAPara reemplazar respuestas dependiendo de una condición en particular se puede utilizar la función case_when() dentro de un mutate().De esta manera en la variable Var se reemplazará todos los casos que registren el dato de Text por New_Text .","code":"\ntrial_data %>% \n  mutate(\n    randomized_group = factor(randomized_group),\n    complete_the_study = factor(complete_the_study)\n  )\n#> # A tibble: 400 × 10\n#>    patient_number baseline_13c_ubt randomized_group\n#>             <dbl> <chr>            <fct>           \n#>  1              1 Positive         group B         \n#>  2              2 Positive         group A         \n#>  3              3 Positive         group B         \n#>  4              4 Positive         group A         \n#>  5              5 Positive         group A         \n#>  6              6 Positive         group A         \n#>  7              7 Positive         group B         \n#>  8              8 Positive         group A         \n#>  9              9 Positive         group A         \n#> 10             10 Positive         group A         \n#> # … with 390 more rows, and 7 more variables:\n#> #   follow_4_weeks <chr>, adverse_drug_reactions <chr>,\n#> #   adverse_drug_reactions_content <chr>,\n#> #   adverse_drug_reaction_classified <chr>,\n#> #   complete_the_study <fct>, uncompleted_reason <chr>,\n#> #   per_protocol_analysis <chr>\ntrial_data %>% \n  mutate(\n    Var = case_when(\n      Var == \"Text\" ~ \"New_Text\", \n      TRUE ~ Var\n    )\n  )"},{"path":"sesión-03.html","id":"uso-de-count","chapter":"Capítulo 4 Sesión 03","heading":"4.1.6 Uso de count","text":"La función count es bastante sencilla y poderosa la vez. Permite obtener una tabla en formato tibble que representará las frecuencias (cantidades n) de una o múltiples variables en específico.La tabla generada muestra que cantidad de personas han tenido reacciones adversas los medicamentos ya sea en el Grupo o B. Sin embargo, también se aprecia que hay 2 respuestas que indican la presencia de datos vacíos: NA y <NA>. El primero está codificado directamente como texto (character) y sel segudo es un NA real, es decir que comunica la ausencia de un dato.","code":"\ntrial_data %>% \n  count(adverse_drug_reactions)\n#> # A tibble: 4 × 2\n#>   adverse_drug_reactions     n\n#>   <chr>                  <int>\n#> 1 NA                        10\n#> 2 No                       295\n#> 3 Yes                       94\n#> 4 <NA>                       1"},{"path":"sesión-03.html","id":"uso-de-mutate-y-case_when","chapter":"Capítulo 4 Sesión 03","heading":"4.1.7 Uso de mutate() y case_when()","text":"","code":""},{"path":"sesión-03.html","id":"explicación-previa-del-na","chapter":"Capítulo 4 Sesión 03","heading":"4.1.7.1 Explicación previa del NA","text":"Al importar las bases de datos dentro de R, la gran mayoría de funciones (como read_excel()) interpretarán los valors en blanco o celdas vacías como reales NA. Sin embargo si en las celdas se ha llenado explícitamente el texto NA o se ha usado alguna codificación diferente, el valor de NA se introducirá automáticamente y habrá que indicarlo como tal (case_when()).","code":"\ntrial_data %>% \n  count(adverse_drug_reactions)\n#> # A tibble: 4 × 2\n#>   adverse_drug_reactions     n\n#>   <chr>                  <int>\n#> 1 NA                        10\n#> 2 No                       295\n#> 3 Yes                       94\n#> 4 <NA>                       1"},{"path":"sesión-03.html","id":"uso-de-case_when","chapter":"Capítulo 4 Sesión 03","heading":"4.1.7.2 Uso de case_when()","text":"La función case_when() tiene una aplicación directa y perfecta para estos fines, en el que recodificaremos el NA introducido como texto un NA real que sea reconocido como tal. El mismo procedimiento se utilizaría si los valores faltantes o perdidos se hubieran codificado de otra forma (ej. 777 o 999).Recordar que con pipe (%>%) podemos anidar muchas funciones en un solo bloque:El código TRUE ~ adverse_drug_reactions significa que todos los demás casos mantendrán el valor original que el de la variable.","code":"\ntrial_data %>%\n  mutate(\n    adverse_drug_reactions = case_when(\n      adverse_drug_reactions == \"NA\" ~ NA_character_,\n      TRUE ~ adverse_drug_reactions\n    )\n  ) %>% \n  count()#> # A tibble: 1 × 1\n#>       n\n#>   <int>\n#> 1   400"},{"path":"sesión-03.html","id":"advertencia","chapter":"Capítulo 4 Sesión 03","heading":"4.1.7.3 Advertencia","text":"La función case_when requiere respetar de forma estricta el tipo de vector utilizado. Es decir que si se le pide recodificar una variable número, y dentro de esa variable continúan habiendo textos, habrá un problema de -coerción. Es por ese motivo que en el anterior ejemplo se usa NA_character en vez de únicamente NA, ya que este elemento como tal en realidad es de tipo lógico.","code":"\ntypeof(NA)\n#> [1] \"logical\"\ntypeof(NA_character_)\n#> [1] \"character\"\ntypeof(NA_real_)\n#> [1] \"double\""},{"path":"sesión-03.html","id":"más-sobre-case_when","chapter":"Capítulo 4 Sesión 03","heading":"4.1.8 Más sobre case_when()","text":"Anteriormente vimos como usar la función case_when para recategorizar/recodificar variables en base una condición de igualdad (==). Sin embargo, es la única manera. También se puede recategorizar en base múltiples condiciones, como %% (comparar con múltiples valores la vez), >, >=, < y <=, en conjunto con & y |.Para ejemplificar esto haremos una recategorización de la base nycflights13::flights:Consideraremos del mes 1 hasta el 6 como 2013-y partir del mes 7, como 2013-II.Ya que la variable month es de tipo integer (numérica) tenemos más formas alternativas de conseguir exactamente el mismo resultado mostrado anteriormente.En variables numéricas, podemos directamente usar <= en las condiciones.O directamente usar TRUE ~ “Condicion, para todos los demás casos.","code":"\nnycflights13::flights %>% \n  count(year, month)\n#> # A tibble: 12 × 3\n#>     year month     n\n#>    <int> <int> <int>\n#>  1  2013     1 27004\n#>  2  2013     2 24951\n#>  3  2013     3 28834\n#>  4  2013     4 28330\n#>  5  2013     5 28796\n#>  6  2013     6 28243\n#>  7  2013     7 29425\n#>  8  2013     8 29327\n#>  9  2013     9 27574\n#> 10  2013    10 28889\n#> 11  2013    11 27268\n#> 12  2013    12 28135\nnycflights13::flights %>% \n  mutate(\n    year = case_when(\n      month %in% 1:6 ~ \"2013-I\",\n      TRUE ~ \"2013-II\"\n    )\n  ) %>% \n  count(year)\n#> # A tibble: 2 × 2\n#>   year         n\n#>   <chr>    <int>\n#> 1 2013-I  166158\n#> 2 2013-II 170618\nnycflights13::flights %>% \n  mutate(\n    year = case_when(\n      month <= 6 ~ \"2013-I\",\n      month > 6 ~ \"2013-II\"\n    )\n  ) %>% \n  count(year)\n#> # A tibble: 2 × 2\n#>   year         n\n#>   <chr>    <int>\n#> 1 2013-I  166158\n#> 2 2013-II 170618\nnycflights13::flights %>% \n  mutate(\n    year = case_when(\n      month <= 6 ~ \"2013-I\",\n      TRUE ~ \"2013-II\"\n    )\n  ) %>% \n  count(year)\n#> # A tibble: 2 × 2\n#>   year         n\n#>   <chr>    <int>\n#> 1 2013-I  166158\n#> 2 2013-II 170618"},{"path":"sesión-03.html","id":"más-usos-de-count-y-arrange","chapter":"Capítulo 4 Sesión 03","heading":"4.1.9 Más usos de count() y arrange()","text":"Ya hemos visto que count() es sumamente útil. Además, basta con agregar más variables dentro de sus argumentos, para que estos automáticamente ingresen generar una tabla de frecuencias. Sin embargo, veces puede ser necesario ordenar esos resultados, para ello usaremos arrange().La función arrange() permitirá ordenar un objeto en base una o múltiples variables. En caso se ejecute sobre una variable numérica, se ordenará de menor mayor por defecto, y en caso se ejecute sobre una variable texto (character) se ordenará de forma alfabética, tal y como ya lo hace count() por defecto.Si se desea invertir el ordenamiento, se puede utilizar la función desc() dentro de arrange().","code":"\ntrial_data <- trial_data %>% \n  mutate(\n    follow_4_weeks = case_when(\n      follow_4_weeks == \"NA\" ~ NA_character_,\n      TRUE ~ follow_4_weeks\n    ),\n    adverse_drug_reactions = case_when(\n      adverse_drug_reactions == \"NA\" ~ NA_character_,\n      TRUE ~ adverse_drug_reactions\n    )\n  )\ntrial_data %>% \n  count(randomized_group, \n        follow_4_weeks,\n        adverse_drug_reactions)trial_data %>%\n  count(randomized_group,\n        follow_4_weeks,\n        adverse_drug_reactions) %>%\n  arrange(randomized_group,\n          desc(follow_4_weeks))#> # A tibble: 13 × 4\n#>    randomized_group follow_4_weeks adverse_drug_react…     n\n#>    <chr>            <chr>          <chr>               <int>\n#>  1 group A          Negative       No                    124\n#>  2 group A          Negative       Yes                    31\n#>  3 group A          Positive       No                     27\n#>  4 group A          Positive       Yes                    14\n#>  5 group A          <NA>           <NA>                    4\n#>  6 group B          Negative       No                    114\n#>  7 group B          Negative       Yes                    41\n#>  8 group B          Negative       <NA>                    4\n#>  9 group B          Positive       No                     25\n#> 10 group B          Positive       Yes                     8\n#> 11 group B          Positive       <NA>                    2\n#> 12 group B          <NA>           No                      5\n#> 13 group B          <NA>           <NA>                    1"},{"path":"sesión-03.html","id":"uso-de-slice_max","chapter":"Capítulo 4 Sesión 03","heading":"4.1.10 Uso de slice_max()","text":"Anteriormente conocido como top_n(), la función slice_max(), permite seleccionar cuantos casos (filas) se específique en base una variable numérica.","code":"\ntrial_data %>%\n  count(randomized_group,\n        follow_4_weeks) %>%\n  slice_max(order_by = n,\n            n = 2)\n#> # A tibble: 2 × 3\n#>   randomized_group follow_4_weeks     n\n#>   <chr>            <chr>          <int>\n#> 1 group B          Negative         159\n#> 2 group A          Negative         155"},{"path":"sesión-03.html","id":"introducción-a-tidydata","chapter":"Capítulo 4 Sesión 03","heading":"4.1.11 Introducción a tidydata","text":"Tener datos ordenados (tidydata) significa tener una BD con estructuras adecuadas, donde cada registro representa una fila, cada variable representa una columna y cada celda contiene una simple medida (Hadley Wickham,2014).","code":""},{"path":"sesión-03.html","id":"uso-de-pivot_longer-y-pivot_wider","chapter":"Capítulo 4 Sesión 03","heading":"4.1.12 Uso de pivot_longer() y pivot_wider()","text":"Para este ejemplo usaremos una base de datos que contiene casos de personas fallecidas causa del coranovirus nivel de país, este dataset está alojada en el siguiente repositorio de GitHub (click aquí).La función read_csv del paquete readr (se carga automáticamente cuando se realiza library(tidyverse)), permite importar archivos csv (data) incluso cuando el archivo está en una web.","code":"\ncovid19 <- read_csv(\"https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv\")\n#> Rows: 285 Columns: 859\n#> ── Column specification ───────────────────────────────────────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr   (2): Province/State, Country/Region\n#> dbl (857): Lat, Long, 1/22/20, 1/23/20, 1/24/20, 1/25/20...\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ncovid19\n#> # A tibble: 285 × 859\n#>    `Province/State`  `Country/Region`   Lat   Long `1/22/20`\n#>    <chr>             <chr>            <dbl>  <dbl>     <dbl>\n#>  1 <NA>              Afghanistan       33.9  67.7          0\n#>  2 <NA>              Albania           41.2  20.2          0\n#>  3 <NA>              Algeria           28.0   1.66         0\n#>  4 <NA>              Andorra           42.5   1.52         0\n#>  5 <NA>              Angola           -11.2  17.9          0\n#>  6 <NA>              Antarctica       -71.9  23.3          0\n#>  7 <NA>              Antigua and Bar…  17.1 -61.8          0\n#>  8 <NA>              Argentina        -38.4 -63.6          0\n#>  9 <NA>              Armenia           40.1  45.0          0\n#> 10 Australian Capit… Australia        -35.5 149.           0\n#> # … with 275 more rows, and 854 more variables:\n#> #   `1/23/20` <dbl>, `1/24/20` <dbl>, `1/25/20` <dbl>,\n#> #   `1/26/20` <dbl>, `1/27/20` <dbl>, `1/28/20` <dbl>,\n#> #   `1/29/20` <dbl>, `1/30/20` <dbl>, `1/31/20` <dbl>,\n#> #   `2/1/20` <dbl>, `2/2/20` <dbl>, `2/3/20` <dbl>,\n#> #   `2/4/20` <dbl>, `2/5/20` <dbl>, `2/6/20` <dbl>,\n#> #   `2/7/20` <dbl>, `2/8/20` <dbl>, `2/9/20` <dbl>, …"},{"path":"sesión-03.html","id":"pivot","chapter":"Capítulo 4 Sesión 03","heading":"4.1.12.1 ¿Pivot?","text":"Tenemos un conjunto de datos donde cada una de las fechas de fallecimiento por Covid-19 se encuentran almacenadas como columnas.Sin embargo, esta forma de organizar la información podría generar dificultades al momento de pre-procesar la información o realizar algún tipo de análisis. Tener todas las fechas y casos de muerte por COVID-19 en 2 columnas (fecha y fallecidos), podría ayudar este proceso.","code":""},{"path":"sesión-03.html","id":"pivotear","chapter":"Capítulo 4 Sesión 03","heading":"4.1.12.2 Pivotear","text":"Así, dependiendo de el formato inicial de los datos, tendremos que pivotear hacia la derecha (wider) o hacia abajo (longer).","code":""},{"path":"sesión-03.html","id":"uso-de-pivot_longer","chapter":"Capítulo 4 Sesión 03","heading":"4.1.13 Uso de pivot_longer()","text":"La función pivot_longer permitirá pasar todas las fechas que están lo largo de las columnas 2: fecha y fallecidos.","code":"\ncovid19_tidy <- covid19 %>%\n  select(-c(Lat:Long)) %>%\n  pivot_longer(\n    cols = -c(`Province/State`:`Country/Region`),\n    names_to = \"fecha\",\n    values_to = \"fallecidos\"\n  )"},{"path":"sesión-03.html","id":"uso-de-pivot_wider","chapter":"Capítulo 4 Sesión 03","heading":"4.1.14 Uso de pivot_wider()","text":"De forma análoga, la función pivot_wider() hará exactamente lo contrario, pasar de una data que se encuentre ordenada (tidy data), una data ancha. Para esta función se tendrá que indicar los argumentos: names_from y values_from.","code":"\ncovid19_tidy %>%\n  pivot_wider(\n    names_from = \"fecha\",\n    values_from = \"fallecidos\"\n  )\n#> # A tibble: 285 × 857\n#>    `Province/State`     `Country/Region` `1/22/20` `1/23/20`\n#>    <chr>                <chr>                <dbl>     <dbl>\n#>  1 <NA>                 Afghanistan              0         0\n#>  2 <NA>                 Albania                  0         0\n#>  3 <NA>                 Algeria                  0         0\n#>  4 <NA>                 Andorra                  0         0\n#>  5 <NA>                 Angola                   0         0\n#>  6 <NA>                 Antarctica               0         0\n#>  7 <NA>                 Antigua and Bar…         0         0\n#>  8 <NA>                 Argentina                0         0\n#>  9 <NA>                 Armenia                  0         0\n#> 10 Australian Capital … Australia                0         0\n#> # … with 275 more rows, and 853 more variables:\n#> #   `1/24/20` <dbl>, `1/25/20` <dbl>, `1/26/20` <dbl>,\n#> #   `1/27/20` <dbl>, `1/28/20` <dbl>, `1/29/20` <dbl>,\n#> #   `1/30/20` <dbl>, `1/31/20` <dbl>, `2/1/20` <dbl>,\n#> #   `2/2/20` <dbl>, `2/3/20` <dbl>, `2/4/20` <dbl>,\n#> #   `2/5/20` <dbl>, `2/6/20` <dbl>, `2/7/20` <dbl>,\n#> #   `2/8/20` <dbl>, `2/9/20` <dbl>, `2/10/20` <dbl>, …"},{"path":"sesión-04.html","id":"sesión-04","chapter":"Capítulo 5 Sesión 04","heading":"Capítulo 5 Sesión 04","text":"","code":""},{"path":"sesión-04.html","id":"exploración-competencial","chapter":"Capítulo 5 Sesión 04","heading":"5.1 Exploración competencial","text":"","code":""},{"path":"sesión-04.html","id":"uso-de-filter","chapter":"Capítulo 5 Sesión 04","heading":"5.1.1 Uso de filter()","text":"","code":""},{"path":"sesión-04.html","id":"para-que-sirve-1","chapter":"Capítulo 5 Sesión 04","heading":"5.1.1.1 ¿Para que sirve?","text":"Ayuda crear un subconjunto de datos con todas las filas que cumplan tus condiciones.\nPueden incluirse varias condiciones dentro de un filtro.Ayuda crear un subconjunto de datos con todas las filas que cumplan tus condiciones.\nPueden incluirse varias condiciones dentro de un filtro.Funciones y operadores útiles:\nDe comparación: ==, <, >, <=, >=, !=, %%, .na, !.na\nDe lógica: &, |, xor, !, (), ()\nFunciones y operadores útiles:De comparación: ==, <, >, <=, >=, !=, %%, .na, !.naDe comparación: ==, <, >, <=, >=, !=, %%, .na, !.naDe lógica: &, |, xor, !, (), ()De lógica: &, |, xor, !, (), ()","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ────────────────────────────────────────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n#> ✔ tibble  3.1.7     ✔ dplyr   1.0.9\n#> ✔ tidyr   1.2.0     ✔ stringr 1.4.0\n#> ✔ readr   2.1.2     ✔ forcats 0.5.1\n#> ── Conflicts ───────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\nnycflights13::flights\n#> # A tibble: 336,776 × 19\n#>     year month   day dep_time sched_dep_time dep_delay\n#>    <int> <int> <int>    <int>          <int>     <dbl>\n#>  1  2013     1     1      517            515         2\n#>  2  2013     1     1      533            529         4\n#>  3  2013     1     1      542            540         2\n#>  4  2013     1     1      544            545        -1\n#>  5  2013     1     1      554            600        -6\n#>  6  2013     1     1      554            558        -4\n#>  7  2013     1     1      555            600        -5\n#>  8  2013     1     1      557            600        -3\n#>  9  2013     1     1      557            600        -3\n#> 10  2013     1     1      558            600        -2\n#> # … with 336,766 more rows, and 13 more variables:\n#> #   arr_time <int>, sched_arr_time <int>, arr_delay <dbl>,\n#> #   carrier <chr>, flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>,\n#> #   distance <dbl>, hour <dbl>, minute <dbl>,\n#> #   time_hour <dttm>"},{"path":"sesión-04.html","id":"ejemplo-2","chapter":"Capítulo 5 Sesión 04","heading":"5.1.1.2 Ejemplo","text":"Esta data muestra información de la NOAA acerca de tormentas desde 1975 hasta el 2020.Si quisieramos solo trabajar con los huracanes de categoría 5, tendríamos que hacer lo siguiente con la función filter():","code":"\nstorms %>% \n  count(status, category)\n#> # A tibble: 8 × 3\n#>   status              category     n\n#>   <chr>               <ord>    <int>\n#> 1 hurricane           1         1933\n#> 2 hurricane           2          749\n#> 3 hurricane           3          434\n#> 4 hurricane           4          411\n#> 5 hurricane           5           86\n#> 6 tropical depression -1        2898\n#> 7 tropical storm      0         5347\n#> 8 tropical storm      1            1\nstorms %>% \n  filter(status == \"hurricane\",\n         category == 5)\n#> # A tibble: 86 × 13\n#>    name   year month   day  hour   lat  long status category\n#>    <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <chr>  <ord>   \n#>  1 Anita  1977     9     2     0  24.6 -96.2 hurri… 5       \n#>  2 Anita  1977     9     2     6  24.2 -97.1 hurri… 5       \n#>  3 David  1979     8    30     6  16   -64.2 hurri… 5       \n#>  4 David  1979     8    30    12  16.3 -65.2 hurri… 5       \n#>  5 David  1979     8    30    18  16.6 -66.2 hurri… 5       \n#>  6 David  1979     8    31     0  16.8 -67.3 hurri… 5       \n#>  7 David  1979     8    31     6  17   -68.3 hurri… 5       \n#>  8 David  1979     8    31    12  17.2 -69.1 hurri… 5       \n#>  9 David  1979     8    31    18  17.9 -69.7 hurri… 5       \n#> 10 Gilb…  1988     9    13    18  19.4 -82.5 hurri… 5       \n#> # … with 76 more rows, and 4 more variables: wind <int>,\n#> #   pressure <int>, tropicalstorm_force_diameter <int>,\n#> #   hurricane_force_diameter <int>"},{"path":"sesión-04.html","id":"uso-de-select","chapter":"Capítulo 5 Sesión 04","heading":"5.2 Uso de select()","text":"Esta función permite seleccionar las variables de interés.Esta función permite seleccionar las variables de interés.Puede ser útil previo un análisis de datos o solo si se desea tener una data menos larga.Puede ser útil previo un análisis de datos o solo si se desea tener una data menos larga.Para usarlo se puede nombrar las variables dentro de la función select() y/o usar el comando : para indcar hastaPara usarlo se puede nombrar las variables dentro de la función select() y/o usar el comando : para indcar hastaEl uso de las funciones con pipe (%>%) permite anidarlas una tras otra. Además, si las columnas están una lado de otra, podemos usar : para seleccionar varios al mismo tiempo.","code":"\nstorms %>% \n  filter(status == \"hurricane\",\n         category == 5) %>% \n  select(name, year, month, day, hour, wind)\n#> # A tibble: 86 × 6\n#>    name     year month   day  hour  wind\n#>    <chr>   <dbl> <dbl> <int> <dbl> <int>\n#>  1 Anita    1977     9     2     0   140\n#>  2 Anita    1977     9     2     6   150\n#>  3 David    1979     8    30     6   140\n#>  4 David    1979     8    30    12   145\n#>  5 David    1979     8    30    18   150\n#>  6 David    1979     8    31     0   145\n#>  7 David    1979     8    31     6   145\n#>  8 David    1979     8    31    12   145\n#>  9 David    1979     8    31    18   150\n#> 10 Gilbert  1988     9    13    18   140\n#> # … with 76 more rows\nstorms %>% \n  filter(status == \"hurricane\",\n         category == 5) %>% \n  select(name:hour, wind)\n#> # A tibble: 86 × 6\n#>    name     year month   day  hour  wind\n#>    <chr>   <dbl> <dbl> <int> <dbl> <int>\n#>  1 Anita    1977     9     2     0   140\n#>  2 Anita    1977     9     2     6   150\n#>  3 David    1979     8    30     6   140\n#>  4 David    1979     8    30    12   145\n#>  5 David    1979     8    30    18   150\n#>  6 David    1979     8    31     0   145\n#>  7 David    1979     8    31     6   145\n#>  8 David    1979     8    31    12   145\n#>  9 David    1979     8    31    18   150\n#> 10 Gilbert  1988     9    13    18   140\n#> # … with 76 more rows"},{"path":"sesión-04.html","id":"mutate-ii-1","chapter":"Capítulo 5 Sesión 04","heading":"5.3 Mutate II","text":"Esta función del paquete dplyr nos permite agregar o modificar las variables actuales en un conjunto de datos (dataframe). Tal y como ya lo vimos en la sesión 03, esta función puede hacer cambios sobre una o múltiples variables existentes, así como crear varias la vez serparándolas con una coma (Y. Wendy Huynh,2019).","code":"\ndata %>% \n  mutate(\n    var1 = old_var*2,\n    var2 = old_var*3,\n    var3 = var1*var2\n  )"},{"path":"sesión-04.html","id":"mutate-ii-uso-de-across","chapter":"Capítulo 5 Sesión 04","heading":"5.4 Mutate II: Uso de across()","text":"Haremos la prueba con la base storm. Usando la función across() para aplicar una función múltiples variables la vez. En esta ocasión transformaremos en factores las variables status y category de tormentas.","code":"\nstorms %>% \n  select(name:pressure) %>% \n  mutate(\n    status = as.factor(status),\n    category = as.factor(category)\n  ) %>% \n  glimpse()\n#> Rows: 11,859\n#> Columns: 11\n#> $ name     <chr> \"Amy\", \"Amy\", \"Amy\", \"Amy\", \"Amy\", \"Amy\",…\n#> $ year     <dbl> 1975, 1975, 1975, 1975, 1975, 1975, 1975,…\n#> $ month    <dbl> 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n#> $ day      <int> 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 2…\n#> $ hour     <dbl> 0, 6, 12, 18, 0, 6, 12, 18, 0, 6, 12, 18,…\n#> $ lat      <dbl> 27.5, 28.5, 29.5, 30.5, 31.5, 32.4, 33.3,…\n#> $ long     <dbl> -79.0, -79.0, -79.0, -79.0, -78.8, -78.7,…\n#> $ status   <fct> tropical depression, tropical depression,…\n#> $ category <ord> -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, …\n#> $ wind     <int> 25, 25, 25, 25, 25, 25, 25, 30, 35, 40, 4…\n#> $ pressure <int> 1013, 1013, 1013, 1013, 1012, 1012, 1011,…\nstorms %>% \n  select(name:pressure) %>% \n  mutate(\n    across(c(status, category), as.factor)\n  ) %>% \n  glimpse()\n#> Rows: 11,859\n#> Columns: 11\n#> $ name     <chr> \"Amy\", \"Amy\", \"Amy\", \"Amy\", \"Amy\", \"Amy\",…\n#> $ year     <dbl> 1975, 1975, 1975, 1975, 1975, 1975, 1975,…\n#> $ month    <dbl> 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,…\n#> $ day      <int> 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 2…\n#> $ hour     <dbl> 0, 6, 12, 18, 0, 6, 12, 18, 0, 6, 12, 18,…\n#> $ lat      <dbl> 27.5, 28.5, 29.5, 30.5, 31.5, 32.4, 33.3,…\n#> $ long     <dbl> -79.0, -79.0, -79.0, -79.0, -78.8, -78.7,…\n#> $ status   <fct> tropical depression, tropical depression,…\n#> $ category <ord> -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, …\n#> $ wind     <int> 25, 25, 25, 25, 25, 25, 25, 30, 35, 40, 4…\n#> $ pressure <int> 1013, 1013, 1013, 1013, 1012, 1012, 1011,…"},{"path":"sesión-04.html","id":"mutate-ii-lubridate","chapter":"Capítulo 5 Sesión 04","heading":"5.5 Mutate II: lubridate","text":"Muchas veces durante el pre-procesamiento de datos tenemos que enfrentarnos manejo de fechas (crear, transformar, etc.). Para estos fines podemos usar las funciones del paquete lubridate.Para tener una mejor apreciación de la variable de fecha que crearemos, usaremos relocate() para reposicionar la variable creada.","code":"\nstorms %>%\n  select(name:pressure) %>%\n  mutate(\n    date = lubridate::make_date(year, month, day)\n  ) %>%\n  relocate(date, .before = year)\n#> # A tibble: 11,859 × 12\n#>    name  date        year month   day  hour   lat  long\n#>    <chr> <date>     <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n#>  1 Amy   1975-06-27  1975     6    27     0  27.5 -79  \n#>  2 Amy   1975-06-27  1975     6    27     6  28.5 -79  \n#>  3 Amy   1975-06-27  1975     6    27    12  29.5 -79  \n#>  4 Amy   1975-06-27  1975     6    27    18  30.5 -79  \n#>  5 Amy   1975-06-28  1975     6    28     0  31.5 -78.8\n#>  6 Amy   1975-06-28  1975     6    28     6  32.4 -78.7\n#>  7 Amy   1975-06-28  1975     6    28    12  33.3 -78  \n#>  8 Amy   1975-06-28  1975     6    28    18  34   -77  \n#>  9 Amy   1975-06-29  1975     6    29     0  34.4 -75.8\n#> 10 Amy   1975-06-29  1975     6    29     6  34   -74.8\n#> # … with 11,849 more rows, and 4 more variables:\n#> #   status <chr>, category <ord>, wind <int>,\n#> #   pressure <int>"},{"path":"sesión-04.html","id":"uso-de-group_by","chapter":"Capítulo 5 Sesión 04","heading":"5.6 Uso de group_by()","text":"Esta función permite poder indicarle R que las operaciones que hagamos en adelante, sean divididas y aplicadas por las agrupaciones que sea haya formado. Es decir, que se puede hacer la agrupación por una o múltiples variables.La función group_by() solo configura como será el tratamiento de la data en adelante. observará ningún cambio percepctible en los datos con excepción de:","code":"\nstorms %>% \n  filter(year >= 2010) %>% \n  group_by(name)\n#> # A tibble: 3,608 × 13\n#> # Groups:   name [112]\n#>    name   year month   day  hour   lat  long status category\n#>    <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <chr>  <ord>   \n#>  1 Alex   2010     6    25    18  16.4 -83.1 tropi… -1      \n#>  2 Alex   2010     6    26     0  16.6 -83.9 tropi… -1      \n#>  3 Alex   2010     6    26     6  16.7 -84.9 tropi… 0       \n#>  4 Alex   2010     6    26    12  16.9 -86.1 tropi… 0       \n#>  5 Alex   2010     6    26    18  17.2 -87.2 tropi… 0       \n#>  6 Alex   2010     6    27     0  17.5 -88.2 tropi… 0       \n#>  7 Alex   2010     6    27     6  18   -89.1 tropi… 0       \n#>  8 Alex   2010     6    27    12  18.5 -90   tropi… 0       \n#>  9 Alex   2010     6    27    18  18.9 -90.7 tropi… 0       \n#> 10 Alex   2010     6    28     0  19.2 -91.1 tropi… 0       \n#> # … with 3,598 more rows, and 4 more variables: wind <int>,\n#> #   pressure <int>, tropicalstorm_force_diameter <int>,\n#> #   hurricane_force_diameter <int># Groups:   name [112]"},{"path":"sesión-04.html","id":"uso-de-summarise","chapter":"Capítulo 5 Sesión 04","heading":"5.7 Uso de summarise()","text":"Esta función permite obtener algun resumen de los datos, como la media, desviación estándar, valores máximos, mínimos, calculos de prueba estadística, y la mayoría de funciones de esta naturaleza. El uso conjunto de group_by() y summarise() es una combinación perfecta.","code":"\nmtcars %>%\n  group_by(cyl) %>%\n  summarise(\n    avg = mean(mpg)\n  )\n#> # A tibble: 3 × 2\n#>     cyl   avg\n#>   <dbl> <dbl>\n#> 1     4  26.7\n#> 2     6  19.7\n#> 3     8  15.1"},{"path":"sesión-04.html","id":"uso-de-summarise-1","chapter":"Capítulo 5 Sesión 04","heading":"5.8 Uso de summarise()","text":"Usaremos la misma BD de COVID-19 que empleamos en la sesión 03.Este dataset está alojada en el siguiente repositorio de GitHub (click aquí).Mediante la función read_csv podremos importar la data directamente desde Github.","code":"\ncovid19 <- read_csv(\"https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv\")\n#> Rows: 285 Columns: 859\n#> ── Column specification ───────────────────────────────────────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr   (2): Province/State, Country/Region\n#> dbl (857): Lat, Long, 1/22/20, 1/23/20, 1/24/20, 1/25/20...\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ncovid19\n#> # A tibble: 285 × 859\n#>    `Province/State`  `Country/Region`   Lat   Long `1/22/20`\n#>    <chr>             <chr>            <dbl>  <dbl>     <dbl>\n#>  1 <NA>              Afghanistan       33.9  67.7          0\n#>  2 <NA>              Albania           41.2  20.2          0\n#>  3 <NA>              Algeria           28.0   1.66         0\n#>  4 <NA>              Andorra           42.5   1.52         0\n#>  5 <NA>              Angola           -11.2  17.9          0\n#>  6 <NA>              Antarctica       -71.9  23.3          0\n#>  7 <NA>              Antigua and Bar…  17.1 -61.8          0\n#>  8 <NA>              Argentina        -38.4 -63.6          0\n#>  9 <NA>              Armenia           40.1  45.0          0\n#> 10 Australian Capit… Australia        -35.5 149.           0\n#> # … with 275 more rows, and 854 more variables:\n#> #   `1/23/20` <dbl>, `1/24/20` <dbl>, `1/25/20` <dbl>,\n#> #   `1/26/20` <dbl>, `1/27/20` <dbl>, `1/28/20` <dbl>,\n#> #   `1/29/20` <dbl>, `1/30/20` <dbl>, `1/31/20` <dbl>,\n#> #   `2/1/20` <dbl>, `2/2/20` <dbl>, `2/3/20` <dbl>,\n#> #   `2/4/20` <dbl>, `2/5/20` <dbl>, `2/6/20` <dbl>,\n#> #   `2/7/20` <dbl>, `2/8/20` <dbl>, `2/9/20` <dbl>, …"},{"path":"sesión-04.html","id":"uso-de-summarise-2","chapter":"Capítulo 5 Sesión 04","heading":"5.9 Uso de summarise()","text":"Recordar que primero debemos pivotear la data para poder trabajar con ella. Obtendremos resúmenes de casos por muerte COVID-19 por países.Guardaremos la data pivoteada en un objeto llamado covid19_tidy, para extender demasiado el código. Además, veamos lo sencillo que es poder introducir un filter los resultados obtenidos.","code":"\ncovid19 %>%\n  select(-c(Lat:Long)) %>%\n  pivot_longer(\n    cols = -c(`Province/State`:`Country/Region`),\n    names_to = \"fecha\",\n    values_to = \"fallecidos\"\n  ) %>%\n  group_by(`Country/Region`) %>%\n  summarise(\n    M = mean(fallecidos, na.rm = TRUE),\n    DE = sd(fallecidos, na.rm = TRUE),\n    Max = max(fallecidos, na.rm = TRUE),\n    Min = min(fallecidos, na.rm = TRUE)\n  ) %>%\n  arrange(desc(M))\n#> # A tibble: 199 × 5\n#>    `Country/Region`       M      DE     Max   Min\n#>    <chr>              <dbl>   <dbl>   <dbl> <dbl>\n#>  1 US               475952. 318956. 1003783     0\n#>  2 Brazil           339999. 247925.  666261     0\n#>  3 India            248756. 197983.  524525     0\n#>  4 Mexico           170959. 116077.  324768     0\n#>  5 Russia           130325. 125818.  370972     0\n#>  6 Peru             126790.  76672.  213134     0\n#>  7 Italy             89646.  52660.  166264     0\n#>  8 Colombia          70098.  53530.  139833     0\n#>  9 Iran              69298.  49668.  141293     0\n#> 10 Indonesia         63898.  61469.  156553     0\n#> # … with 189 more rows\ncovid19_tidy <- covid19 %>%\n  select(-c(Lat:Long)) %>%\n  pivot_longer(\n    cols = -c(`Province/State`:`Country/Region`),\n    names_to = \"fecha\",\n    values_to = \"fallecidos\"\n  )\ncovid19_tidy %>%\n  group_by(`Country/Region`) %>%\n  summarise(\n    M = mean(fallecidos, na.rm = TRUE),\n    DE = sd(fallecidos, na.rm = TRUE),\n    Max = max(fallecidos, na.rm = TRUE),\n    Min = min(fallecidos, na.rm = TRUE)\n  ) %>%\n  arrange(desc(M))\n#> # A tibble: 199 × 5\n#>    `Country/Region`       M      DE     Max   Min\n#>    <chr>              <dbl>   <dbl>   <dbl> <dbl>\n#>  1 US               475952. 318956. 1003783     0\n#>  2 Brazil           339999. 247925.  666261     0\n#>  3 India            248756. 197983.  524525     0\n#>  4 Mexico           170959. 116077.  324768     0\n#>  5 Russia           130325. 125818.  370972     0\n#>  6 Peru             126790.  76672.  213134     0\n#>  7 Italy             89646.  52660.  166264     0\n#>  8 Colombia          70098.  53530.  139833     0\n#>  9 Iran              69298.  49668.  141293     0\n#> 10 Indonesia         63898.  61469.  156553     0\n#> # … with 189 more rows\ncovid19_tidy %>%\n  mutate(\n    fecha = lubridate::mdy(fecha)\n  ) %>%\n  filter(fecha > \"2022-01-01\") %>%\n  group_by(`Country/Region`) %>%\n  summarise(\n    M = mean(fallecidos, na.rm = TRUE),\n    DE = sd(fallecidos, na.rm = TRUE),\n    Max = max(fallecidos, na.rm = TRUE),\n    Min = min(fallecidos, na.rm = TRUE)\n  ) %>% \n  arrange(desc(M))\n#> # A tibble: 199 × 5\n#>    `Country/Region`       M     DE     Max    Min\n#>    <chr>              <dbl>  <dbl>   <dbl>  <dbl>\n#>  1 US               945018. 54717. 1003783 825081\n#>  2 Brazil           648584. 16406.  666261 619401\n#>  3 India            511463. 13813.  524525 481893\n#>  4 Russia           347356. 20976.  370972 304284\n#>  5 Mexico           316733.  8801.  324768 299544\n#>  6 Peru             209806.  3563.  213134 202782\n#>  7 Italy            155081.  8444.  166264 137646\n#>  8 Indonesia        150826.  5167.  156553 144097\n#>  9 Colombia         137432.  3316.  139833 130026\n#> 10 Iran             137382.  3734.  141293 131680\n#> # … with 189 more rows"},{"path":"taller-i.html","id":"taller-i","chapter":"Capítulo 6 Taller I","heading":"Capítulo 6 Taller I","text":"","code":""},{"path":"taller-i.html","id":"introducción","chapter":"Capítulo 6 Taller I","heading":"6.1 Introducción","text":"Esta fase del curso tiene por intención desarrollar un proceso de análisis de datos en base los conceptos mostrados y explicados en las 3 primeras sesiones. Mediante una serie de instrucciones y la posibilidad de consultar pistas/ayudas referenciadas, se busca que el estudiante pueda aplicar conceptos y desarrolle las habilidades procedimentales para lograr dar solución los problemas planteados.","code":""},{"path":"taller-i.html","id":"instrucciones","chapter":"Capítulo 6 Taller I","heading":"6.2 Instrucciones","text":"En este proyecto usaremos la información dispuesta en la página de Vigilancia Del Sistema De Información Del Estado Nutricional en EESS del Instituto Nacional de Salud (INS). Específicamente trataremos con la base de datos de estado nutricional de niños menores de 5 años en el Periodo: Enero-Diciembre 2021.Descargar la base de datos en mención del siguiente enlace y posicionarlo en un nuevo proyecto Rstudio con sus carpetas respectivas: https://web.ins.gob.pe/sites/default/files/Archivos/cenan/van/informes/2021/1.Indic%20Ni%C3%B1os%20a%20Diciembre%202021%20-%20PERU.xlsxLa base de datos contiene información variada acerca de niveles de anemia y estado nutricional de niños desde los 6 meses de edad hasta los 5 años nivel departamental, provincial y distrital. Para estos ejercicios vamos requerir importar únicamente la información de los niveles de anemia en niños de 6 35 meses que accedieron los establecimientos de salud, según el departamento.\n\nAyuda 1\n\nEsta data se encuentra en la pestaña Anemia 6-35x DEP\n\n\nAyuda 2\n\nPara omitir la lectura de filas iniciales que podrían contener información relevante, revisa el argumento skip de la función read_excel.\n\n\nEsta data se encuentra en la pestaña Anemia 6-35x DEP\n\nPara omitir la lectura de filas iniciales que podrían contener información relevante, revisa el argumento skip de la función read_excel.\nLa columna que contiene la información de los departamentos tiene todos sus registros en mayúsculas. Será necesario tener esos registros en formato Sentence case, es decir que las letras con el que empiecen las palabras sean en mayúsculas y el resto en minúsculas. Por ej. “AMAZONAS” “Amazonas”, “PIURA” “Piura”, “LIMA” “Lima”, etc.\n\nAyuda 1\n\nLas funciones mutate() y str_to_sentence() serán útiles para completar esta petición.\n\n\nLas funciones mutate() y str_to_sentence() serán útiles para completar esta petición.\nIdentificar los departamentos y su pertenencia la región geográfica correspondiente (costa, sierra y selva). Tener en cuenta:Costa: Callao, Ica, La Libertad, Lambayeque, Lima, Piura, Tacna, Tumbes.Sierra: Ancash, Apurímac, Arequipa, Ayacucho, Cajamarca, Cusco, Huancavelica, Huánuco, Junín, Moquegua, Pasco, Puno.Selva: Amazonas, Loreto, Madre de Dios, San Martín, Ucayali.\n\nAyuda 1\n\nPara clasificar una variable existente, revisar: mutate() y case_when().\n\n\nPara clasificar una variable existente, revisar: mutate() y case_when().\nSobre la clasificación anterior, mostrar lo siguiente:Mostrar los 5 departamentos con mayor cantidad de casos por Anemia Total.Número de departamentos que reportan casos de anemia por región geográfica.Casos totales de anemia por región geográfica.\n\nAyuda 1\n\nLa función slice_max() es útil para seleccionar los casos más frecuentes en base otra (cantidad, por ej.)\n\n\nAyuda 2\n\nLa función count() es útil para generar tablas de frecuencias y contabilizar casos.\n\n\nAyuda 3\n\nRevisar: Uso de group_by(), summarize() y sum().\n\n\nLa función slice_max() es útil para seleccionar los casos más frecuentes en base otra (cantidad, por ej.)\n\nLa función count() es útil para generar tablas de frecuencias y contabilizar casos.\n\nRevisar: Uso de group_by(), summarize() y sum().\nPor último, es necesario transformar la base de datos de tal manera que los tipos de anemia se encuentren en una sola columna y la cantidad de ellos se encuentren en diferentes filas/observaciones.\n\nAyuda 1\n\nLa función pivot_longer() puede agrupar varias columnas en una sola.\n\n\nLa función pivot_longer() puede agrupar varias columnas en una sola.\n¡Éxtitos en el taller!","code":""}]
